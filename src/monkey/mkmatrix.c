/* mkmatrix.c: Analyzes dictionary and writes matrix.c */

#include "global.h"
#include <sys/types.h>
#include <ctype.h>

/* The purpose of this program is to write a c-source file containing the
commands necessary to produce at run time a tree structured dictionary of
transition probabilities. This program takes as input a sample text file
to analyze which should be quite large for best results. The default is
/usr/dict/words, but this can be changed with a command line option. The
dictionary is searched for each possible string up to the desired depth,
and then one node in the ultimate tree corresponds to each such string.
For example, if the string "foo" occurs N times in the sample text, the
corresponding node will contain N in its frequency field. (See global.h
for the complete declaration of the node structure.) The parent of foo
is "fo", and among its children is the node "fool". 

The program first analyzes the sample text and creates an in core 
representation of the tree -- this phase is called the read phase below.
It then traverses the tree recursively and writes the commands necessary
to allocate and link each node encountered. These commands collectively
make up a routine called matrix() which is invoked from main at run time. 

Other than boilerplate things like "matrix(){" and "return;", the
only C-commands that get written have the form

SetFreq(&ANode,N);  -- AND -- AddChild(ANode,AName);

These commands are implemented in node.c and basically do what they say. 

(See the example file matrix.c in the doc directory).

Actually the above is a bit of a lie. At depth 2 the resulting C file is
huge -- about 460k -- too big for gcc to handle on my system. The solution
is to split the commands creating the tree over many files. Thus the
write phase of this program actually writes some 50 files called
matrix1.c, matrix2.c ... . Each such file creates one main branch of
the tree and ends by calling the function implemented in the next such
file. 

The write phase ends by writing a file called build.h which contains the
declarations of all the functions mentioned above. This gets included by each 
of the matrixi.c files.


*/



#define INFO  "mkmatrix: analyze dictionary, write matrix*.c and build.h.\n\
usage: mkmatrix [-i -l] [-d dictionary] [-depth <n>] [-dir <path>]\n\
-i: ignore case in dictionary.\n\
-l: ignore everthing but letters of the alphabet in dictionary.\n\
-d: take the following as path to the dictionary (default:/usr/dict/words).\n\
-dir: write output in given directory.\n\
-depth: compile statistics for all strings to given length+1.\n"

#define USAGE "mkmatrix [-d dictionary] [-depth <n>] [-dir <path>] [-l] [-i]"
#define MAX_ARG_LEN 80             /* Max length of combined options */

/* Boiler plate that goes at top of each matrix.c file */
#define BOILER "\
/* Don't edit. This file is generated by mkmatrix */\n\
\n\
#include \"../global.h\"\n\
#include \"build.h\"\n"

/* You're a bad boy, using global variables. */

int caseflag = 1;      /* distinguish case by default */
int allcharsflag = 1; /* count all characters, not just letters */
char pathbuf[256] = "./matrix";
int filecount = 0;

int find_opt(char *option_string);
void myerror(char *fmt, ...);
FILE *startfile(int);
void endfile(FILE *);
int myfgetc(FILE *);

struct NodeStruct Root = {"",0,0,NULL,NULL,NULL,NULL};
char ProgramName[256];

int main(int argc, char **argv)
{
	int c=-1;                /* numeric option code */
	int i,j,n,m,k,s,t;
	char *info = INFO;
	char opsep = '-';      /* Standard for Unix */
	char argstr[MAX_ARG_LEN];
	int g;
	struct NodeStruct *ANode,*HNode,*BNode,*CNode,*DNode,*ENode;
	int depth = MAXDEPTH;
	char readstring[MAXDEPTH+2];
	char head[MAXDEPTH+1];
	FILE *dictionary,*output;
	char dictname[256];

/* Copy the default dictionary name */
	strcpy(dictname,"/usr/share/dict/words");

/* Program name is available in ProgramName */
	strcpy(ProgramName,argv[0]);

/* Process Command Line Options */

if(--argc > 0){  /* Anything on command line ? */
                ++argv;
                while((argc > 0)&&((*argv[0]) == opsep)){ /* loop while 
							there are flags */
                        argstr[0]=opsep;
                        argstr[1]='\0';
                        strcat(argstr,++*argv); /* glob argstr*/
                        argc--;
                        while((argc>0)&&(strlen(*argv)<3)&&
				((*(argv+1))[0]==opsep)&&((*(argv+1))[1]!=opsep)){
                                ++argv;
                                argc--;
                                strcat(argstr,++*argv);
                        }
                        ++argv; /* ok, consecutive flags now globbed into one*/
                       c = find_opt(argstr+1); /* look up flag code */
                switch(c){

			case -1: break;  /* default, e.g no options */

			case 0: printf("%s\n",info);
				return 0;
			case 1: if(argc == 0){
					myerror(USAGE);
					return 1;
				}
				strcpy(dictname,*(argv++));
			        argc--;
				break;
			case 6: allcharsflag=0;
			case 2: caseflag = 0;
				break;
			case 3: allcharsflag = 0;
				break;
			case 4: if(argc == 0){
					myerror(USAGE);
					return 1;
				}
				strcpy(pathbuf,*(argv++));
			        argc--;
				break;
			case 5: if(argc == 0){
					myerror(USAGE);
					return 1;
				}
				depth = atoi(*(argv++));
			        argc--;
				if(depth > MAXDEPTH){
					myerror("Maxdepth %d assumed.\n",MAXDEPTH);
					depth = MAXDEPTH;
				}
				break;
                        case -2: ;  /* barf (don't use in your code) */
			default:
				fprintf(stderr,"%s: illegal option\n",argstr);
				fprintf(stderr,USAGE);
				return 1;
			} /* End flag switch */
	} /* End flag grabbing while loop */
} /* end if: any args ? */

/* Done processing command line */

	/* Open the dictionary for read */
	if((dictionary = fopen(dictname,"r"))==NULL){
		myerror(" unable to open %s\n",dictname);
		return 1;
	}

/* READ PHASE */

	printf("Reading the dictionary %s\n", dictname);

/* strings of length 1 */

	printf("Counting strings of length 1...\n");

/* myfgetc returns 0 for characters we've decided to skip */

	while((g=myfgetc(dictionary))!=EOF){
		if(!g)continue;
		Root.freq++;
		readstring[0]=g;
		readstring[1]='\0';		
		if((ANode = GetNode(readstring,&Root))==NULL)
			SetFreq(AddChild(&Root,g),1);
		else
			SetFreq(ANode,ANode->freq+1);
	}	
	rewind(dictionary);

/* strings of length 2 */
	
	if(depth < 1) goto write;

	printf("Counting strings of length 2...\n");

	while(!(g=myfgetc(dictionary)));
	readstring[0]=g;
	while((g=myfgetc(dictionary))!=EOF){
		if(!g)continue;
		readstring[1]=g;
		readstring[2]='\0';
		head[0]=readstring[0];
		head[1]='\0';	
		HNode=GetNode(head,&Root);
		if((ANode = GetNode(readstring,HNode))==NULL)
			SetFreq(AddChild(HNode,g),1);
		else
			SetFreq(ANode,ANode->freq+1);
		readstring[0]=g;
	}	
	rewind(dictionary);

/* strings of length 3 */

	if(depth < 2) goto write;

	printf("Counting strings of length 3...\n");

	while(!(g=myfgetc(dictionary)));
	readstring[0]=g;
	while(!(g=myfgetc(dictionary)));
	readstring[1]=g;
	while((g=myfgetc(dictionary))!=EOF){
		if(!g)continue;
		readstring[2]=g;
		readstring[3]='\0';
		head[0]=readstring[0];
		head[1]=readstring[1];
		head[2]='\0';	
		HNode=GetNode(head,&Root);
		if((ANode = GetNode(readstring,HNode))==NULL)
			SetFreq(AddChild(HNode,g),1);
		else
			SetFreq(ANode,ANode->freq+1);
		readstring[0]=readstring[1];
		readstring[1]=g;	
	}	
	rewind(dictionary);


/* strings of length 4 */

	if(depth < 3) goto write;

	printf("Counting strings of length 4...\n");

	while(!(g=myfgetc(dictionary)));
	readstring[0]=g;
	while(!(g=myfgetc(dictionary)));
	readstring[1]=g;
	while(!(g=myfgetc(dictionary)));
	readstring[2]=g;
	while((g=myfgetc(dictionary))!=EOF){
		if(!g)continue;
		readstring[3]=g;
		readstring[4]='\0';
		head[0]=readstring[0];
		head[1]=readstring[1];
		head[2]=readstring[2];
		head[3]='\0';	
		HNode=GetNode(head,&Root);
		if((ANode = GetNode(readstring,HNode))==NULL)
			SetFreq(AddChild(HNode,g),1);
		else
			SetFreq(ANode,ANode->freq+1);
		readstring[0]=readstring[1];
		readstring[1]=readstring[2];
		readstring[2]=g;	
	}	
	rewind(dictionary);

/* strings of length 5 */

        if(depth < 4) goto write;

        printf("Counting strings of length 5...\n");

        while(!(g=myfgetc(dictionary)));
        readstring[0]=g;
        while(!(g=myfgetc(dictionary)));
        readstring[1]=g;
        while(!(g=myfgetc(dictionary)));
        readstring[2]=g;
	while(!(g=myfgetc(dictionary)));
        readstring[3]=g;
        while((g=myfgetc(dictionary))!=EOF){
                if(!g)continue;
                readstring[4]=g;
                readstring[5]='\0';
                head[0]=readstring[0];
                head[1]=readstring[1];
                head[2]=readstring[2];
                head[3]=readstring[3];
                head[4]='\0';
                HNode=GetNode(head,&Root);
                if((ANode = GetNode(readstring,HNode))==NULL)
                        SetFreq(AddChild(HNode,g),1);
                else
                        SetFreq(ANode,ANode->freq+1);
                readstring[0]=readstring[1];
                readstring[1]=readstring[2];
                readstring[2]=readstring[3];
                readstring[3]=g;
        }


	fclose(dictionary);

/* WRITE PHASE */

write:

	/* Open new source file, write top part of it */
	output = startfile(++filecount);

        ANode = Root.firstchild;
	fprintf(output,"%s%d%s\n","SetFreq(&Root,",Root.freq,");");

        for(i=0;i<Root.num_children;i++){
                fprintf(output,"%s","ANode=AddChild(&Root,\'");
                g = *(ANode->name);
                if((g=='\'')||(g=='\"'))
                  fprintf(output,"\\%c",g);
                else
                  fprintf(output,"%c",g);
                fprintf(output,"%s\n","');");
                fprintf(output,"%s","SetFreq(ANode,");
                fprintf(output,"%d",ANode->freq);
                fprintf(output,"%s",");\n");

        /* Loop Over Children */
                BNode = ANode->firstchild;
	if(depth > 0)
        for(j=0;j<ANode->num_children;j++){
                        fprintf(output,"%s","BNode=AddChild(ANode,\'");
                        g = *(BNode->name+1);
                        if((g=='\'')||(g=='\"'))
                          fprintf(output,"\\%c",g);
                        else
			fprintf(output,"%c",g);
                        fprintf(output,"%s\n","');");
                        fprintf(output,"%s","SetFreq(BNode,");
                        fprintf(output,"%d",BNode->freq);
                        fprintf(output,"%s",");\n");

	/* Loop Over Children of Children */
			CNode = BNode->firstchild;
			if(depth > 1)
			for(k=0;k<BNode->num_children;k++){
                          	fprintf(output,"%s","CNode=AddChild(BNode,\'");
                        	g = *(CNode->name+2);
                        	if((g=='\'')||(g=='\"'))
                          		fprintf(output,"\\%c",g);
                        	else
				fprintf(output,"%c",g);
                        	fprintf(output,"%s\n","');");
                        	fprintf(output,"%s","SetFreq(CNode,");
                        	fprintf(output,"%d",CNode->freq);
                        	fprintf(output,"%s",");\n");

	/* Loop Over Children of Children of Children */
				DNode = CNode->firstchild;
				if(depth > 2)
				for(s=0;s<CNode->num_children;s++){
                          		fprintf(output,"%s","DNode=AddChild(CNode,\'");
                        		g = *(DNode->name+3);
                        		if((g=='\'')||(g=='\"'))
                          			fprintf(output,"\\%c",g);
                        		else
					fprintf(output,"%c",g);
                        		fprintf(output,"%s\n","');");
                        		fprintf(output,"%s","SetFreq(DNode,");
                        		fprintf(output,"%d",DNode->freq);
                        		fprintf(output,"%s",");\n");

       /* Loop Over Children of Children of Children of Children */

                                  ENode = DNode->firstchild;
                                  if(depth > 3)
                                  for(t=0;t<DNode->num_children;t++){
                                        fprintf(output,"%s","ENode=AddChild(DNode,\'");
					g = *(ENode->name+4);
                                        if((g=='\'')||(g=='\"'))
                                                fprintf(output,"\\%c",g);
                                        else
                                        fprintf(output,"%c",g);
                                        fprintf(output,"%s\n","');");
                                        fprintf(output,"%s","SetFreq(ENode,");
                                        fprintf(output,"%d",ENode->freq);
                                        fprintf(output,"%s",");\n");
					ENode =ENode->sibling;
               				 }

	             		  DNode = DNode->sibling;
				}
				CNode=CNode->sibling;
			}
                        BNode=BNode->sibling;
                }
                ANode = ANode->sibling;
		if(i<Root.num_children - 1){	
			fprintf(output,"%s%d%s\n","CreatMatrix",++filecount,
					"();");
			endfile(output);
			output = startfile(filecount);
		}
        }
	endfile(output);

        /* Write build.h */

	strcat(pathbuf,"/build.h");
        if((output = fopen(pathbuf,"w"))==NULL){
                fatal(stderr," unable to open %s\n","build.h");
        }
	fprintf(output,"#define DEPTH %d\n",depth);
	for(i=0;i<filecount;i++)
		fprintf(output,"%s%d%s\n","extern void CreatMatrix",i+1,"();");
	fclose(output);

	return 0;

}

/*  find_opt: return a unique small integer for each possible option string */
/*  There should be a case in the switch statement in main to handle each. */
/*  -2 reserved for arg not found -1 reserved for no options */

/* N.B. word doesn't contain the leading hyphen */

int find_opt(char *word)
{
	if(strcmp(word,"help")==0)return 0;
	if(strcmp(word,"d")==0)return 1;
	if(strcmp(word,"i")==0)return 2;
	if(strcmp(word,"l")==0)return 3;
	if(strcmp(word,"dir")==0)return 4;
	if(strcmp(word,"depth")==0)return 5;
	if(strcmp(word,"il")==0)return 6;
	if(strcmp(word,"li")==0)return 6;
	

/* arg not found */
	return -2;
}

/* myerror: generic error reporting routine */

void myerror(char *fmt, ...)
{
        va_list args;

        va_start(args,fmt);
        fprintf(stderr,"%s: ",ProgramName);
        vfprintf(stderr,fmt,args);
        fprintf(stderr,"\n");
        va_end(args);
        exit(1);
}

/* Generic error routine */

void fatal(FILE *stream,char *fmt, ...)
{
        va_list args;

        va_start(args,fmt);
        fprintf(stream,"%s: Fatal Error.\n","mseq");
        vfprintf(stream,fmt,args);
        fprintf(stream,"\n");
        va_end(args);

        exit(1);
}


FILE *startfile(int num)
{

	char namebuf[256];
	char littlebuf[30];
	FILE *output;

	sprintf(littlebuf,"%s%d%s","/matrix",num,".c");
	sprintf(namebuf,"%s%s",pathbuf,littlebuf);

        /* Open the outputfile for write */
        if((output = fopen(namebuf,"w"))==NULL){
                fatal(stderr, " unable to open %s\n",namebuf);
        }

	printf("Writing matrix%d.c ...\n",num);
        fprintf(output,"%s",BOILER);
        fprintf(output,"void CreatMatrix%d()\n{",num);
        fprintf(output,"%s\n","struct NodeStruct *ANode,*BNode,*CNode,*DNode,*ENode;");
	return output;
}

void endfile(FILE *output)
{
        fprintf(output,"\n%s\n","return;\n}");
        fclose(output);
}

/* Version of fgetc that converts newlines into spaces and ignores case
   and/or non alphabetic chars if requested. Returns 0 if char ignored. */

int myfgetc(FILE *input)
{
	int c;

	c = fgetc(input);
	if(c==EOF)return EOF;
	if(!caseflag)c = tolower(c);
	if(c=='\n')return ' ';
	if((!allcharsflag)&&(!isalpha(c)))return 0;	
	return c;
}
