This package contains C and C++ source code for a command line application 
named debruijn that creates debruijn strings of a given order n using various
algorithms. A debruijn string of order n is a sequence of binary digits that 
contains all 2^n possible binary sequences of length n in a string of minimal
length. The minimum length is easily seen to be 2^n + n - 1. It is a 
remarkable fact that this minimum length is achieved for every n. For
example, 1111011001010000111 is a debruijn string of order 4. 

See the survey article H. Fredrickson, A Survey of Full Length Nonlinear
Shift Register Cycles, SIAM Review 24(1982), 195-221 for a good introduction
to algorithms for generating debruijn sequences and many useful references.
The author's paper DeBruijn Strings, Double Helices, and the Ehrenfeucht-
Mycielski Mechanism is included as a pdf (EM2.pdf) with the package.

BUILD/INSTALL (LINUX, FREEBSD, other Unices?) 

The makefile has two defines that may be edited: MAX_LEVEL sets the largest 
order (n) supported by the program. MAX_STRING should be made equal to 
2^MAX_LEVEL. The default values are 16 and 65536. (These may also be
defined in debruijn.h.)  You should also edit
INSTALL_DIR to something appropriate. 

The Unix command 

	make debruijn

should create an executable named debruijn that can then be manually
installed in any convenient directory. The makefile has a target named install
that will copy debruijn to INSTALL_DIR and set permissions to 555. Depending
on the system, this may require root priveleges. 

WINDOWS

The author developed the package under Visual Studio 2005, so a windows port
as a console app should be completely straightforward. One needs to 
use the makefile.win in place of makefile and #define
the WIN32 macro. makefile.win compiles the c++ source file main.cpp in place
of main.c. (NOTE: I actually built the program under the VS 2005 IDE and have
never tested the makefile. It probably needs some fixing.) 

USAGE

The command debruijn -h will give a terse description of usage, including 
available options and what they do. debruijn -2 will print  all possible 
debruijn cycles of order 2. Options -3, -4, and -5 also list all possible
cycles of the given order. (There are too many cycles at order 6 or higher to 
make listing them all feasible.) All output from the program (other than error
messages) goes to stdout, so if you wish save the results for later use
you will have to redirect output to a file. For example, the 
command debruijn -5 > foo will result in a file foo that contains all 2048 
possible debruijn cycles of order 5. (If foo already exists, any existing
content is overwritten by this command.) 

The command debruijn n will create a single debruijn string of order n by 
the default algorithm. Other strings of order n can be generated by supplying
an optional seed argument, which is an arbitrary binary string following
the order argument. Thus, 

	debruijn 6 1101111110 

will create a debruijn string of order 6 using the binary string 1101111110 
as seed. See the author's paper entitled DeBruijn Strings, Double Helices,
and the Ehrenfeucht-Mycielski Mechanism for the theory behind the default
algorithm. This paper is available as a preprint from ArXiv.org, and also from
the author's website (http://barnyard.syr.edu/research). 

The seed can be supplied from a plain text file instead of the command line
by using the -f option. Thus

	debruijn -f bar 6

will read the seed stored in a file named bar. (The file should contain only
the seed, on a single line.) 

A selection of other algorithms is available with the -m option. Each 
algorithm has an associated number that selects it. For example

	debruijn -m 2 5 11011

creates a debruijn string of order 5 using algorithm 2 and seed 11011. Some
algorithms ignore the seed, but all require the order argument. Here are
the currently supported algorithms, with selection numbers:

selection number 1: prefer one algorithm (key ignored). If order = n, begin
with initial n string 00...01. Always follow with digit 1 unless that would
cause a repeated n string. Otherwise follow with 0.

selection number 2: key word algorithm. The name for this algorithm is due 
to Solomon Golomb and a description and proof can be found on p. 133 of
Golomb's book "Shift Register Sequences". The seed argument is used as the
key word. If order = n, all but the first n digits of the seed are ignored. 
If the seed has fewer than n digits the program exits with an error 
message. The algorithm tries to hold off producing the key word as long as
possible.

selection number 3: key sequence algorithm. This algorithm is also described
in Golomb's book following the key word algorithm. Unlike the key word 
algorithm, which for for large n only generates a small fraction of possible
debruijn sequences, the key sequence algorithm can generate all possible 
debruijn sequences in terms of lower order ones. To generate an order n 
sequence, the algorithm requires two pieces of data: (1) a debruijn sequence
of order n-1 (called the key sequence); and (2) an arbitrary function 
(preference function) whose domain is binary strings of length n-2 and whose
range is {0,1}. It is very awkward to allow for specification of an 
arbitrary function on the command line, and so we only partially implement
the key sequence algorithm in selection numbers 3 and 4. With selection
number 3, the key sequence is provided by means of the seed argument (on
command line or in a file) and the preference function is taken to
be the constant function equal to 1.

selection number 4: same as number 3, except the preference function returns
a random binary digit. (The RNG is seeded by the first n digits of the key
sequence. To generate different sequences with the same key sequence, one
could use rotations of the corresponding debruijn cycle.)  

selection number 5: A sequence based on a linear recurrence of order n is 
produced. The initial n string is taken to be 00...01. After that, the kth 
binary digit x_k is given by x_k = c_1*x_(k-1) + c_2*x_(k-2) + ...
+ c_n*x_(k-n), where the arithmetic is done modulo 2. The coefficients
c_1,...,c_n, of the linear recurrence are determined by the binary digits of the
seed argument. A linear recurrence can never produce a debruijn string since
it cannot produce the all zero n-string without getting trapped there. The
program fixes this by adding an extra zero at the start after the sequence
is complete.  Even then, most seeds will not produce a debruijn string.
If the command is given without the seed argument, but with the order (n)
argument, then it will list all seeds it knows about that yield a genuine
debruijn string of order n. For example, the command

	debruijn -m 5 4

produces the output

23 31

This means both 23 and 31 used as seeds will produce a genuine debruijn
string:

	debruijn -m 5 4 31
0000100110101111000

The seed is interpreted by the program as a number in octal code whose binary
digits give the coefficients of the characteristic polynomial of the
recurrence: c_nx^n + ... + c_1x + 1. In the example, since 031 = 011001 in
binary, the polynomial is x^4 + x^3 + 1, and the recurrence is x_k = x_(k-2) +
x_(k-4). 

selection number 6: The prefer same algorithm is used (seed argmument ignored.)
This algorithm starts with n zeros followed by n ones, and thereafter seeks
to generate the longest runs of one or zero possible, consistent with the 
total numbers of runs of each length that must be present. See Fredrickson's
paper for more details.

selection number 7: The prefer opposite algorithm is used (seed argument
ignored.) This algorithm, discovered by Abbas Alhakim, prefers the opposite
of the last digit added (start with n zeros), unless that would duplicate
the terminal n string. In this form, the string with n ones will never appear,
so the last string with n-1 ones must be supplemented. 

Some further options modify the output in all cases where a debruijn string
is produced:

-v: produce more verbose output. In the present version of the program the
    added information is somewhat limited. For example, without any other
    options present it will present a tracing of the induced hamiltonian
    circuit on the debruijn graph (which is pretty obvious) and will announce
    the fact that there are 2^n vertices. This is only really useful in
    verifying that the output is really debruijn, say when the linear option
    is used with an untested octal code.

-b: print the string in reverse order

-c: print the bitwise complement (for example 00110 becomes 11001.)

-r: rotate output by k digits, where k is an argument supplied immediately
    after the -r. Conceptually, remove the last n-1 digits and wrap the
    remaining digits clockwise around a circle so that the last digit comes
    just before the first. Rotate the circle counterclockwise k places, and then
    reverse the steps. For example, with 0011101000 and k = 1 the steps 
    are 0011101000 -> 00111010 -> 01110100 -> 0111010001

-a: dump anti-path cycle decomposition. If the edges of the hamiltonian cycle
    of the debruijn graph induced by a given debruijn string are removed from
    the graph, the reamining graph has exactly one outgoing and one incoming
    edge at each vertex, and so decomposes into a set of disjoint cycles.
    These cycles are shown by wrapping each one in a pair of parentheses.   

In addition, option -e with argmument n will generate n terms of the
Ehrenfeucht-Mycielski sequence, a pseudo-random sequence that has some
interesting connections with debruijn strings. (See the author's paper for
more information.) The number of terms possible is limited only by 
available memory, not by the MAX_LEVEL macro. 
